<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2018/01/31/test2/</url>
      <content type="html"><![CDATA[<p>final test</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2018/01/31/test1/</url>
      <content type="html"><![CDATA[<p>a test again</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2018/01/31/test/</url>
      <content type="html"><![CDATA[<p>just a test</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[gitPage + hexo 搭建博客]]></title>
      <url>/2018/01/29/build-blog/</url>
      <content type="html"><![CDATA[<p>利用 gitPage 和 hexo 搭建一个博客</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>Github Pages 是一个可用于托管静态页面的平台，站点免费托管在 github 上，使用 gitPage 来放我们的页面时，首先要在 github 建立相应的仓库，并且仓库名命名方式为： username.github.io</p>
<p><img src="/upload/build-blog/name-gitpage.PNG" alt="仓库取名"></p>
<p>这个时候我们放在该仓库中的静态页面可以通过 https：//username.github.io 去打开，比如这里是： <a href="https://lcsc-frontend.github.io/" target="_blank" rel="noopener">https://lcsc-frontend.github.io/</a></p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>hexo，一款基于 node 的博客框架，一般使用 markdown 来解析文章，比较方便地根据主题布局和文章生成静态页面。</p>
<p>也就是说，我们可以利用 hexo 这个框架来生成博客的静态页面，然后部署到 gitPage 上，通过 username.github.io 来访问我们的博客。</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ol>
<li><p>搭建前先要有 node 和 git 环境</p>
</li>
<li><p>在 github 上新建一个仓库，名为 username.github.io。（这里的 username 必须是你的用户名，按这种命名方式的仓库是一个“特别”的仓库，可以通过 <a href="https://username.github.io/" target="_blank" rel="noopener">https://username.github.io/</a> 访问）</p>
</li>
<li><p>安装 hexo，找一个合适的地方，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init blog </span><br><span class="line">cd blog</span><br><span class="line">npm install // 安装相关的依赖</span><br><span class="line">hexo g // 生成静态文件，可以看到 blog 中多了几个文件夹 (完整的命令是： hexo generate )</span><br><span class="line">hexo s // 开启本地服务 (完整的命令是： hexo server )</span><br><span class="line">// 执行了 hexo s 之后，可以打开 localhost:4000 看到当前的博客生成的样子 （此时使用的是默认主题）</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改主题<br>hexo 有很多人贡献了主题，比如现在我们想把主题更改为 nexT ，首先克隆 nexT 代码至 /blig/themes/next 目录 （如果要把博客主题也放在 github 上面，可先看看后面“将 blog 相关 hexo 代码放在 github 上”）。接着，我们需要将主题从默认的 landscape 改为我们想要的 next</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next // 可以看到 themes 中有了 next 目录，其中是其相应的布局等文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 找到 blog/_config.yml 配置文件，更改：</span><br><span class="line"># theme: landscape</span><br><span class="line">theme: next</span><br><span class="line"># 主题安装完成，最好先使用 hexo clean 先来清楚 hexo 缓存，然后再 hexo g，hexo d</span><br><span class="line"># 同时，其他主题相关配置都可以在 themes/next/_config.yml 中进行修改。布局等则在 theme 中相关 layout 文件中进行更改，如果你需要的话</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 hexo 部署到 gitPage。hexo 可以部署到不同的平台，这里我们是将它部署到 gitPage 上，首先需要修改 blog/_cofig.yml 文件中的 deploy ，然后安装一个插件 hexo-deployer-git </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 之后执行之前说的命令：</span><br><span class="line">hexo d // 这个时候访问 https://username.github.io/ 可以看到你的博客页面</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="将-blog-相关-hexo-代码放在-github-上"><a href="#将-blog-相关-hexo-代码放在-github-上" class="headerlink" title="将 blog 相关 hexo 代码放在 github 上"></a>将 blog 相关 hexo 代码放在 github 上</h2><p>在 github 上新建一个仓库，我本来以为 push 上去就 okay 了，结果似乎没有那么顺利。发现新的主题 next 没有被 push 上去，ε=(´ο｀*)))唉。怎么处理这个问题？使用 git subtree。将 themes/next 这个主题作为子项目合并到项目中，变成其的一个子目录。</p>
<p>先 fork 你想要的主题到你的 github 账号下，比如我还是 fork next。<br>当然，还是要先将 blog 项目 push 到 github 上去<br>如果你之前就把 next 放在 blog 里了，就先 remove，并把删除记录提交上去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;delete next&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p>
<p>在主项目 blog 中，将子项目 next 添加到远程库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add -f next https://github.com/username/hexo-theme-next.git</span><br><span class="line">git subtree add --prefix=themes/next next master --squash</span><br></pre></td></tr></table></figure></p>
<p>拉取子项目文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch next master</span><br><span class="line">git subtree pull --prefix=themes/next next master --squash</span><br></pre></td></tr></table></figure></p>
<p>这个时候可以在本地看到 next 目录<br>将子目录 push 到远程仓库（子项目）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=themes/next next master</span><br></pre></td></tr></table></figure></p>
<p>将修改 push 到主项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p>
<p>这个时候回到 github ，在主项目中看，可以找到 themes/next 目录。</p>
<h2 id="为博客添加文章评论功能"><a href="#为博客添加文章评论功能" class="headerlink" title="为博客添加文章评论功能"></a>为博客添加文章评论功能</h2><p>此博客文章评论功能是使用 gitment 来实现的。gitment 是一款基于 github issues 的评论系统，以 github 账号登录，评论内容会显示在所有者相应repo 的 issues 中。</p>
<p>整个过程是这样的：</p>
<p>博客所有者的 github 账号中注册 OAuth Application。</p>
<p><img src="/upload/build-blog/new-oauth-app.PNG" alt="新建 OAuth Apps"></p>
<p><img src="/upload/build-blog/register-app.PNG" alt="注册 OAuth Apps"></p>
<p>写上应用的名称，重点是“Authorization callback URL”要写对，写网站（你的博客）的域名。注册成功后，可以看到 Client ID 和 Client Secret</p>
<p><img src="/upload/build-blog/register-success.PNG" alt="注册 OAuth Apps"></p>
<p>然后使用 npm 安装 gitment 插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitment --save</span><br></pre></td></tr></table></figure></p>
<p>在 github 中创建一个仓库，这个仓库之后的 issues 放着博客文章的评论。这里我给仓库取名 git-comments</p>
<p>在 blog/themes/next/_config.yml 中填写相应的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  github_user: xxx # MUST HAVE, Your Github ID</span><br><span class="line">  github_repo: git-comments # MUST HAVE, The repo you use to store Gitment comments</span><br><span class="line">  client_id: xxxxxx # MUST HAVE, Github client id for the Gitment</span><br><span class="line">  client_secret: xxxxxx # EITHER this or proxy_gateway, Github access secret token for the Gitment</span><br></pre></td></tr></table></figure></p>
<p>这个时候可以看到文章后面已经有了评论的相关功能，但是还处于未初始化状态，需要登录账号去进行初始化，但登录账号会直接进入 xxx.github.io，所以要进行初始化操作，首先将最新的部署到 git 上面，执行 hexo g 和 hexo d。登录成功后点击“初始化”按钮，功成身退。</p>
]]></content>
      
        
        <tags>
            
            <tag> git pages </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> git comment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解 npm5 中的 package-lock.json 文件]]></title>
      <url>/2018/01/25/npm-packagelock/</url>
      <content type="html"><![CDATA[<p>npm是一个用于管理package之间依赖关系的管理器，它允许开发者在package.json中标出自己项目对各库包的依赖。在npm5开始，当使用npm时会自动生成一个package-lock.json文件，它是做什么用的呢？</p>
<a id="more"></a>
<h2 id="package-json-和-package-lock-json-的概念"><a href="#package-json-和-package-lock-json-的概念" class="headerlink" title="package.json 和 package-lock.json 的概念"></a>package.json 和 package-lock.json 的概念</h2><h3 id="语义化版本控制规范（Semver）"><a href="#语义化版本控制规范（Semver）" class="headerlink" title="语义化版本控制规范（Semver）"></a>语义化版本控制规范（Semver）</h3><p>在说相关内容之前，先了解一下Semver。它是什么呢？</p>
<p>简介上是这样的：</p>
<blockquote>
<p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的套件越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p>
<p>用一组简单的规则及条件来约束版本号的配置和增长被提出来。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。</p>
<p>在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p>
</blockquote>
<p><img src="/images/npm-packagelock/semver1.png" alt="semver"></p>
<p>相关链接：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></p>
<h3 id="package-json-的使用"><a href="#package-json-的使用" class="headerlink" title="package.json 的使用"></a>package.json 的使用</h3><p>开发者在使用npm管理器时，会在package.json中标出自己项目对各库包的依赖，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;vue&quot;: &quot;^2.4.2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，这里版本前面有个“^”，它表示的意思是“向后/新兼容”。在不超过大版本“2”的前提下，允许下载最新版本，所以如果在package.json中写了这样一条依赖，实际运行npm install时，可能下载的版本并不是 2.4.2 ，而是 2.5.0 之类的更新的版本。</p>
<p>此外还有在版本号前加“~”的，与“^”不同的是，“^”是锁定了大版本号而已，而“~”是锁定了大版本号和次版本号，只允许对修订号不锁定。</p>
<p>大版本号是大修改情况下会更新，一般这种情况下api可能会发生改变；次版本号一般是功能的补充等，api不变；修订号一般是对bug的修复。</p>
<p>所以说，一般情况下，这种向新兼容是没有问题的，不会因为依赖的库的更新也使得我们自己的项目出现error，同时，库自己的bug也可以在我们每次打包的时候，悄无声息地自己随着新的版本被修复了。</p>
<p>当然，完全相同的代码库，在不同时间或者不同npm下载源下，是可能会出现下到的依赖包是不同的，也就是说，你跟你的同事跑同一套代码，但是在你本地上没有任何问题，在他那里却出现了warning之类的情况，可能就是你们其实下载的不是同一个版本的包，而这可能会对项目的运行产生影响。</p>
<p>同时比较值得注意的是，现在semver规范只是一种约定，并不是所有模块都遵循semver语义化版本。（这告诉我们，找模块一定要找靠谱的！）</p>
<p>但是有一些程序员觉得，“与其相信别人，我只相信自己”</p>
<p>所以出现了“锁定版本号”这种现象，关于npm的锁版本号，有两个东西可以提一提： npm-shrinkwrap 和 package-lock 。</p>
<h2 id="锁定版本号"><a href="#锁定版本号" class="headerlink" title="锁定版本号"></a>锁定版本号</h2><h3 id="手动控制？"><a href="#手动控制？" class="headerlink" title="手动控制？"></a>手动控制？</h3><p>可能有人说，不是说“^”允许下载更新的版本，那直接修改 package.json 让依赖的模块不让修改可以吗？</p>
<p>好像可以。但是！</p>
<p>比如说，我们依赖了包A，而包B依赖了包C：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A@0.1.0</span><br><span class="line">  B@0.0.2</span><br><span class="line">    C@0.0.1</span><br></pre></td></tr></table></figure>
<p>你的项目直接依赖只有A，精确控制版本号也只能控制A，那么多层依赖中的B，C，…呢？</p>
<p>程序员怎么可能做这种事╮(╯▽╰)╭</p>
<h3 id="npm-shrikwrap-命令"><a href="#npm-shrikwrap-命令" class="headerlink" title="npm-shrikwrap 命令"></a>npm-shrikwrap 命令</h3><p>其实早在 npm2 的时候，npm 就提供了 shrinkwrap 命令来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm shrinkwrap</span><br></pre></td></tr></table></figure>
<p>shrinkwrap 会在根目录生成 npm-shrinkwrap 文件，之后的 npm install 会参照这个文件的版本来安装。而 shrinkwrap 是根据当前安装的目录结构生成的。所以如果你不能保证 package.json 文件定义的依赖与 node_modules 下已安装的依赖是匹配的，无冗余的，可以在执行 shrinkwrap 命令前清理依赖并安装。</p>
<p>shrinkwrap.json 文件与后来的 package.json 有大致一样的地方，可以一起在 package-lock.json 中看。</p>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>在 npm5 的时候，终于出现了 package.json （因为 yarn 产生的危机感？）。目的是，只要保存了源文件，只要按照这个 package-lock,json 所标示的具体版本下载依赖包，就能确保所有库包与你上次安装的完全一样。</p>
<p>这个文件大致的依赖这样来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> &quot;acorn-dynamic-import&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;2.0.2&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https://registry.npmjs.org/acorn-dynamic-import/-/acorn-dynamic-import-2.0.2.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha1-x1K9IQvvZ5UBtsbLf8hPj0cVjMQ=&quot;,</span><br><span class="line">      &quot;dev&quot;: true,</span><br><span class="line">      &quot;requires&quot;: &#123;</span><br><span class="line">        &quot;acorn&quot;: &quot;4.0.13&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;acorn&quot;: &#123;</span><br><span class="line">          &quot;version&quot;: &quot;4.0.13&quot;,</span><br><span class="line">          &quot;resolved&quot;: &quot;https://registry.npmjs.org/acorn/-/acorn-4.0.13.tgz&quot;,</span><br><span class="line">          &quot;integrity&quot;: &quot;sha1-EFSVrlNh1pe9GVyCUZLhrX8lN4c=&quot;,</span><br><span class="line">          &quot;dev&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>“version”：版本号，<br>“resolved”：该依赖包的压缩包下载地址，<br>“integrity”： 验证已安装的包是否被改动过，（我看着像是一种加密方式，但是具体怎么验证我也不是很懂）<br>“dependencies”： 该依赖包依赖的包</p>
<p>shrinkwrap 与 package-lock 的 json 文件大致是相同的，那么不同的地方在哪里？</p>
<ol>
<li>package-lock 每次 npm 操作都会更新；而 shrinkwrap.json 只有执行该命令时才会生成；</li>
<li>package-lock 只作用于当前项目不会发布;而 npm-shrinkwrap 可以发布并在所有安装它的地方都生效；</li>
<li>同时使用 package-lock.json 和 npm-shrinkwrap.json ， package-lock.json 将被忽略。</li>
</ol>
<p>所以一般而言， package-lock.json 和 npm-shrinkwrap 使用场景：</p>
<ol>
<li>package-lock.json 可以用在开发环境下，保证不同开发人员的依赖是一致的；</li>
<li>npm-shrinkwrap.json 可以在打包前生成，随包发布，来锁定版本，如果你真的想要的话。</li>
</ol>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="npm-install-的过程"><a href="#npm-install-的过程" class="headerlink" title="npm install 的过程"></a>npm install 的过程</h3><ol>
<li>找到直接依赖的模块；</li>
<li>如果有 npm-shrinkwrap.json 文件或者 package-lock.json 文件，则在其中获取版本信息，没有的话，则在 package.json 中获取；</li>
<li>先会去本地缓存（~/.npm）中找这个模块。如果没有找到，就根据压缩包地址，下载模块压缩包，存放在~./npm（cache）中；</li>
<li>查找再下一层依赖；</li>
<li>dedupe依赖树，去掉重复依赖的模块；</li>
<li>安装模块，存在 node_modules 文件夹中。</li>
</ol>
<h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h3><p>registry 是 npm 模块仓库提供的一种查询服务，用户通过 npm 命令下载并安装指定模块，也可以通过 npm 将自己设计的模块放到 registry 上。</p>
<p>npm 的 registry 没有审核机制，因此会存在一些低质量、不安全甚至有害的模块，不过 npm 服务器的管理员也可以删除有害模块并阻止不怀好意的用户。</p>
]]></content>
      
        
        <tags>
            
            <tag> npm </tag>
            
            <tag> package-lock </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[怎么在这里写文章]]></title>
      <url>/2018/01/25/write-new-article/</url>
      <content type="html"><![CDATA[<p>在我们博客写一篇新文章</p>
<a id="more"></a>
<h1 id="拉取blog"><a href="#拉取blog" class="headerlink" title="拉取blog"></a>拉取blog</h1><ol>
<li><p>在你觉得喜欢的目录下，执行命令克隆 blog 代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LCSC-frontend/blog.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 blog 目录，安装相应的依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="编辑和上传"><a href="#编辑和上传" class="headerlink" title="编辑和上传"></a>编辑和上传</h1><ol>
<li>在 blog/source/_posts/ 中新建 md 文件，于此处编写文章</li>
<li><p>执行下面命令，可在本地进行更改，并在 localhost：4000 预览你修改的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>写完之后执行命令生成静态文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新生成的文件部署到 gitPage 上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>将修改 push 到 github 上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开相应地址 <a href="https://lcsc-frontend.github.io/" target="_blank" rel="noopener">我们的博客</a> 即可看到最新的修改。（如果没有，刷新一下试试）</p>
</li>
</ol>
<h1 id="文章基本格式"><a href="#文章基本格式" class="headerlink" title="文章基本格式"></a>文章基本格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---  // 文章的开头都有这个部分，用来写文章title，文章的标签，文章作者。用“---”隔起来</span><br><span class="line">title: xxx</span><br><span class="line">tags: [tag1, tag2, tag3]  // 为文章打上标签，之后可以在“标签选项中看到”</span><br><span class="line">author: tuffy</span><br><span class="line">---</span><br><span class="line">xxxxx  // 在“---”和“&lt;!-- more --&gt;”之间的是文章的摘要，首页部分显示的是这里的内容，如果不写&lt;!-- more --&gt;会整篇文章都显示在首页</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;  // 以下是正文</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果要在文章中放图片的话，在 themes/next/source/upload 中新建你文章的文件夹（一般取跟文章同名）在里面放这篇文章用到的图片，而文章中则以路径 “/upload/article-name/img-name.PNG” 去引用。</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> new article </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
